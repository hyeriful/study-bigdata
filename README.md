# Hadoop
**대량의 자료를 처리할 수 있는 큰 컴퓨터 클러스터에서 동작하는 분산 응용 프로그램을 지원하는 프레웨어 자바 소프트웨어 프레임워크**

- RDBMS와 맵리듀스 비교

||전통적인 RDBMS|맵리듀스|
|------|---|---|
|데이터 크기|기가바이트|페타바이트|
|접근 방식|대화형과 일괄 처리 방식|일괄 처리 방식|
|변경|여러 번 읽고 쓰기|한 번 쓰고 여러 번 읽기|
|구조|쓰기 기준 스키마|일기 기준 스키마|
|무결성|높음|낮음|
|확장성|비선형|선형|

RDBMS는 수 밀리초~수 초 정도의 짧은 응답시간을 요구하고, Hadoop에서는 분산처리를 위한 전처리가 필요하여 최저 10~20초 정도의 오버헤드가 발생한다.  
맵리듀스는 비정형 분석과 같이 일괄 처리 방식으로 전체 데이터셋을 분석할 필요가 있는 문제에 적합하다. RDBMS는 상대적으로 작은 양의 데이터를 낮은 지연 시간에 추출하고 변경하기 위해 데이터셋을 색인하기 때문에 특정 쿼리와 데이터 변경에 적합하다. 맵리듀스는 데이터를 한 번 쓰고 여러 번 읽는 애플리케이션에 적합하지만, 관계형 데이터베이스는 지속적으로 변경되는 데이터셋에 적합하다고 할 수 있다.  

- hadoop cluster  
클러스터란, 특정한 기능수행을 위해 여러 대의 컴퓨터가 네트워크로 연결된 것을 의미하며, 이때 클러스터를 구성하는 개별 컴퓨터를 node라고 한다.
여러 개의 노드가 모여 하나의 rack을 구성하고 rack이 모여 하나의 hadoop cluster를 구축하게 된다.
rack은 물리적으로 같은 network의 switch에 모두 연결 되어 있다. 그렇기 때문에 두 노드의 대역폭은 다른 rack에 있는 노드보다 크게 된다. 즉 데이터의 이동을 할 수 있는 폭이 크기 때문에 데이터 속도가 빠르다. network의 다른 switch에 연결되어 있는 rack으로 인해 성능저하가 발생할 수 있다.
<img width="472" alt="hadoop cluster" src="https://user-images.githubusercontent.com/55703132/110307981-e26e2c00-8042-11eb-9134-5f345a3caa68.png">

## 1. 맵리듀스
대용량의 데이터 처리를 위한 분산 병렬 프로그래밍 모델, 소프트웨어 프레임워크  
맵 리듀스 프레임워크를 이용하면 대규모 분산 컴퓨팅 환경에서 대량의 데이터를 병렬로 분석 가능  
프로그래머가 직접 작성하는 맵과 리듀스라는 두개의 메서드로 구성  

- Map  
흩어져 있는 데이터를 연관성 있는 데이터들로 분류하는 작업. (key, value 형태)
- Reduce  
Map에서 출력된 데이터에서 중복 데이터를 제거하고 원하는 데이터를 추출하는 작업

하둡은 데이터의 일부분이 저장된 클러스터의 각 머신에서 맵리듀스 프로그램을 실행한다. 이를 위해 하둡은 YARN(하둡 자원 관리 시스템)을 이용한다.

### 데이터 흐름
**잡Job**은 클라이언트가 수행하는 작업의 기본 단위이다. 하둡은 잡을 **map task**와 **reduce task**로 나누어 실행한다. 각 태스크는 YARN을 이용하여 스케줄링되고 클러스터의 여러 노드에서 실행된다. 특정 노드의 태스크가 하나 실패하면 자동으로 다른 노드를 재할당 하여 다시 실행된다.  

하둡은 맵리듀스 잡의 입력을 input split(또는 단순히 split)이라고 부르는 고정 크기 조각으로 분리한다. 하둡은 각 스플릿마다 하나의 맵 태스를 생성하고 스플릿의 각 레코드를 사용자 정의 맵 함수로 처리한다. 일반적인 잡의 적절한 스플릿 크기는 HDFS 블록의 기본 크기인 128mb가 적당하다고 알려져 있다.  

하둡은 HDFS 내의 입력 데이터가 있는 노드에서 맵 태스크를 실행할 때 가장 빠르게 작동한다(a). 이를 **data locality optimization(데이터 지역성 최적화)** 라고 하는데, 클러스터의 중요한 공유자원인 네트워크 대역폭을 사용하지 않는 방법이다. 그러나 맵 태스크의 입력 스플릿에 해당하는 HDFS 블록 복제본이 저장된 세 개의 노드 모두 다른 맵 태스크를 실행하여 여유가 없는 상황(데이터 지역성을 위한 가용 슬롯이 없는)이 발생할 수도 있다. 이런 상황에서 잡 스케줄러는 블록 복제본이 저장된 동일 랙에 속한 다른 노드에서 가용한 맵 슬롯을 찾는다(b). 또한 아주 드문 일이지만 데이터 복제본이 저장된 노드가 없는 외부 랙의 노드가 선택될 수도 있는데, 이때에는 랙 간 네트워크 전송이 불가피하게 일어난다(c).

<img width="350" alt="맵 태스크" src="https://user-images.githubusercontent.com/55703132/110323875-90d09c00-8058-11eb-8c5f-2a25bdaa6fad.png">

맵 태스크 결과는 HDFS가 아닌 로컬 디스크에 저장된다. 리듀스의 결과는 HDFS애 저장된다.
리듀스 태스크로 모든 결과를 보내기 전에 맵 태스크가 실패한다면 하둡은 자동으로 해당 맵 태스크를 다른 노드에 할당하여 맵의 출력을 다시 생성할 것이다. 리듀스 태스크는 일반적으로 모든 매퍼의 출력 결과를 입력으로 받기 때문에 데이터 지역성의 장점이 없다. 정렬된 맵의 모든 결과는 네트워크를 통해 일단 리듀스 태스크가 실행 중인 노드로 전송되고, 맵의 모든 결과를 병합 후 사용자 정의 리듀스 함수로 전달된다.  
리듀스 출력에 대한 HDFS 블록의 첫번째 복제본은 로컬 노드에 저장되고, 나머지 복제본은 외부 랙에 저장된다.

## 2. HDFS (Hadoop Distributed FileSystem)
분산 파일 시스템이란?  
네트워크로 연결된 여러 머신의 스토리지를 관리하는 파일시스템

하둡은 HDFS라는 분산 파일시스템을 제공한다.

### 블록  
> HDFS 블록이 큰 이유는?  
> HDFS 블록(128 MB)은 디스크 블록(512 Btye)에 비해 상당히 크다. 그 이유는 **탐색 비용을 최소화**하기 위해서다. 블록이 매우 크면 블록의 시작점을 탐색하는 데 걸리는 시간을 줄일 수 있고 데이터를 전송하는 데 더 많은 시간을 할애할 수 있다.

분산 파일시스템에 **블록 추상화**의 개념이 도입하면서 얻게 된 이득이 있다.
1. 파일 하나의 크기가 단일 디스크의 용량보다 더 커질 수 있다.  
하나의 파일을 구성하는 여러 개의 블록이 동일한 디스크에만 저장될 필요가 없으므로 클러스터에 있는 어떤 디스크에도 저장될 수 있다. (-> 파일은 블록으로 나뉠 수 있고, 블록은 디스크에 저장된다)

2. 파일 단위보다는 블록단위로 추상화를 하면 스토리지의 서브시스템을 단순하게 만들 수 있다.  
블록은 고정 크기고 저장에 필요한 디스크 용량만 계산하면 되기 때문에 메타데이터에 대한 고민을 덜 수 있다. 블록은 단지 저장된 데이터의 청크일 뿐이고 권한 정보와 같은 파일의 메타데이터는 블록과 함께 저장될 필요가 없으므로 별도의 시스템에서 다루도록 분리할 수 있다.

3. 블록은 내고장성(fault tolerance)과 가용성(availability)을 제공하는 데 필요한 복제(replication)를 구현할 때 매우 적합하다.  
블록의 손상과 디스크 및 머신의 장애에 대처하기 위해 각 블록은 물리적으로 분리된 다수의 머신(보통 3개)에 복제된다.

### 네임노드와 데이터노드


## 3. YARN
클러스터 자원 관리 시스템. (Yet Another Resource Negotiator)
